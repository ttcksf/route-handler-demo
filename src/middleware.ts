import { NextResponse, type NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  // 2.クッキーを作成(アプリケーションのCookiesを確認)
  const response = NextResponse.next();
  const themeReference = request.cookies.get('theme');
  if (!themeReference) {
    response.cookies.set('theme', 'dark');
  }
  // 3.ヘッダーを作成(ネットワークの/profileをクリックしてヘッダーを確認)
  response.headers.set('custom-header', 'custom-value');
  return response;

  // 1.profileにアクセスしたらトップページにリダイレクト
  // if (request.nextUrl.pathname === '/profile') {
  //   return NextResponse.redirect(new URL('/', request.url));
  // }
}
// どこでミドルウェアを設定したか
export const config = {
  matcher: '/profile',
};

// React Server Components
// React Server Componentsは、Reactチームによって設計された新しいアーキテクチャです。
// このアプローチは、サーバーとクライアント環境の強みを活用し、効率性、ロード時間、インタラクティビティを最適化することを目指しています。
// アーキテクチャは、クライアントコンポーネントとサーバーコンポーネントを区別するデュアルコンポーネントモデルを導入します。
// この区別は、コンポーネントの機能ではなく、コンポーネントが実行される場所と、コンポーネントが設計されている環境に基づいています。
// クライアントコンポーネント
// クライアントコンポーネントは、私たちがこれまで使用してきた馴染みのあるReactコンポーネントです。
// これらは通常、クライアントサイドでレンダリングされますが、一度サーバー上でHTMLにレンダリングされることもあります。
// これにより、ユーザーは空白の画面ではなく、すぐにページのHTMLコンテンツを見ることができます。
// クライアントコンポーネントがサーバー上でレンダリングされるという考えは混乱するかもしれませんが、クライアント上で主に実行されるコンポーネントであり、最適化としてサーバー上でも実行されるべきであると考えることが有益です。
// クライアントコンポーネントは、ブラウザなどのクライアント環境にアクセスできるため、状態、効果、イベントリスナーを使用してインタラクティビティを処理し、また、geolocationやlocalStorageなどのブラウザ専用のAPIにアクセスして、特定のユースケースのためのUIを構築することができます。
// サーバーコンポーネント
// サーバーコンポーネントは、サーバー上で排他的に動作するように設計された新しいタイプのReactコンポーネントです。
// クライアントコンポーネントとは異なり、そのコードはサーバー上に残り、クライアントにダウンロードされることはありません。
// この設計上の選択は、Reactアプリケーションに複数の利点をもたらします。
// サーバーコンポーネントの利点
// バンドルサイズの削減: サーバーコンポーネントはコードをクライアントに送信しないため、大きな依存関係をサーバーサイドに保つことができます。これにより、インターネット接続が遅いユーザーや性能が低いデバイスのユーザーが恩恵を受けます。
// hydrationの省略: サーバーコンポーネントはhydrationステップを省略するため、アプリケーションのロードとインタラクションが高速化されます。
// 効率的なデータフェッチング: サーバーコンポーネントは、データベースやファイルシステムなどのサーバーサイドリソースに直接アクセスできるため、追加のクライアントサイド処理なしで効率的なデータフェッチングとレンダリングが可能になります。
// セキュリティの強化: サーバーコンポーネントのサーバーサイドでの排他的な実行は、トークンやAPIキーなどの機密データをクライアントから遠ざけることでセキュリティを強化します。
// データフェッチングの効率化: サーバーコンポーネントは、クライアントサイドでuseEffectを使用してデータをフェッチする場合に発生するパフォーマンスの問題を解消します。
// レンダリングのキャッシュ: サーバー上でレンダリングを行うことで、結果をキャッシュすることができ、後続のリクエストや異なるユーザー間で再利用することができます。
// 検索エンジン最適化の向上: サーバーでレンダリングされたHTMLは、検索エンジンボットに完全にアクセス可能であり、ページのインデックス可能性が向上します。
// ストリーミング: サーバーコンポーネントは、レンダリングプロセスを管理可能なチャンクに分割し、準備が整い次第クライアントにストリーミングすることができます。
// クライアントコンポーネントとサーバーコンポーネントの役割
// RSCアーキテクチャでは、サーバーコンポーネントがデータフェッチと静的レンダリングを担当し、クライアントコンポーネントがアプリケーションのインタラクティブな要素をレンダリングします。
// NeXts.jsのアプリルーターはRSCアーキテクチャに基づいているため、これまで説明したすべての機能と利点がNeXts.jsの最新バージョンに組み込まれています。
// Reactのレンダリングの進化を理解することで、NeXts.jsのレンダリングに関する残りのセクションを理解するための必要な背景が得られます。
